2) Fullscreen overlay viewer (no extra packages)

This avoids react-pdf/pdfjs entirely. It uses your existing UI and renders the doc in a modal overlay with no download/print buttons, and it doesn’t close your Player Profile dialog.

Server: stream with “inline” + no-store (optional but recommended)
// GET /api/kyc/:id/stream
res.set({
  'Content-Type': contentType, // application/pdf or image/*
  'Content-Disposition': `inline; filename="${safeName}"`,
  'Cache-Control': 'no-store, no-cache, must-revalidate, proxy-revalidate',
  'Pragma': 'no-cache',
  'Expires': '0',
  'X-Content-Type-Options': 'nosniff',
});
fileStream.pipe(res);

Client: overlay state + viewer (drop into your PlayerProfile component)
// --- 1) state & opener ---
type ViewerDoc = { url: string; name: string; kind: 'pdf' | 'image' | 'other' } | null;
const [viewerDoc, setViewerDoc] = useState<ViewerDoc>(null);

const kindFromName = (name?: string) => {
  const ext = (name || '').split('.').pop()?.toLowerCase();
  if (ext === 'pdf') return 'pdf';
  if (/^(png|jpg|jpeg|gif|webp|bmp)$/i.test(ext || '')) return 'image';
  return 'other';
};

const openViewer = (doc: any) => {
  const { fileUrl, fileName } = normalizeDocumentFields(doc);
  if (!fileUrl) return toast({ title: 'Document Not Available', variant: 'destructive' });
  // Prefer your secure stream over raw storage URL
  const streamUrl = `/api/kyc/${doc.id}/stream`;
  setViewerDoc({ url: streamUrl, name: fileName, kind: kindFromName(fileName) });
};

// Replace window.open(...) with:
<Button
  size="sm"
  variant="outline"
  onClick={() => openViewer(doc)}
  className="border-gray-600 text-gray-200 hover:bg-gray-600"
>
  <Eye className="w-4 h-4 mr-1" />
  View
</Button>

// --- 2) fullscreen overlay ---
function FullscreenDocViewer({
  doc,
  onClose,
}: {
  doc: { url: string; name: string; kind: 'pdf' | 'image' | 'other' };
  onClose: () => void;
}) {
  useEffect(() => {
    const onKey = (e: KeyboardEvent) => e.key === 'Escape' && onClose();
    const prev = document.body.style.overflow;
    document.body.style.overflow = 'hidden';
    window.addEventListener('keydown', onKey);
    return () => {
      document.body.style.overflow = prev;
      window.removeEventListener('keydown', onKey);
    };
  }, [onClose]);

  return (
    <div
      className="fixed inset-0 z-[100] bg-black/90"
      onClick={(e) => {
        // click backdrop to close (optional)
        if (e.target === e.currentTarget) onClose();
      }}
      onContextMenu={(e) => e.preventDefault()} // soft block context menu
    >
      <div className="relative mx-auto mt-6 h-[92vh] w-[min(1200px,95vw)] rounded-xl border border-gray-700 bg-gray-900 shadow-xl">
        <div className="flex items-center justify-between border-b border-gray-800 px-4 py-2">
          <div className="truncate text-sm text-gray-300">{doc.name}</div>
          <button
            className="rounded-md border border-gray-600 px-3 py-1 text-sm hover:bg-gray-700"
            onClick={onClose}
          >
            Close
          </button>
        </div>

        <div className="h-[calc(92vh-44px)] select-none overflow-hidden">
          {doc.kind === 'image' && (
            <div className="h-full w-full overflow-auto p-4">
              <img
                src={doc.url}
                alt={doc.name}
                className="mx-auto max-h-full max-w-full object-contain"
                draggable={false}
              />
            </div>
          )}

          {doc.kind === 'pdf' && (
            <iframe
              // Hide built-in toolbar & nav where supported
              src={`${doc.url}#toolbar=0&navpanes=0&view=FitH`}
              className="h-full w-full"
              // No allow-downloads => blocks programmatic downloads in sandboxed content
              sandbox="allow-scripts allow-same-origin"
            />
          )}

          {doc.kind === 'other' && (
            <iframe
              src={doc.url}
              className="h-full w-full"
              sandbox="allow-scripts allow-same-origin"
            />
          )}
        </div>
      </div>
    </div>
  );
}


Render once near the bottom of your component (inside the main dialog’s JSX so the profile stays open):

{viewerDoc && (
  <FullscreenDocViewer doc={viewerDoc} onClose={() => setViewerDoc(null)} />
)}