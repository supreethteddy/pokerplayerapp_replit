# üöÄ Player Portal Integration ‚Äî Complete Instructions for UUID Chat System

## 1. **Supabase Auth and UUID Player Identity**

- On login/registration, capture the UUID from Supabase Auth:
const playerId = supabase.auth.user().id; // Use this as player_id everywhere!

text

- All chat/session/message creation must use `playerId` (the UUID) not any INT id.

---

## 2. **Submitting a New Chat Request (Session)**

- When player starts a new chat:
const { data, error } = await supabase
.from('chat_requests')
.insert([{
player_id: playerId, // Must be the Supabase UUID!
status: 'waiting', // Initial status for pending tab
message_text: yourInitialMessage,
created_at: new Date().toISOString()
}]);
if (error) showToast('Failed to create chat: ' + error.message);
else showToast('Chat started! A staff member will respond soon.');

text

- **Ensure status:** `'waiting'` for all new requests.  
- **NEVER use INT IDs.** All fields must be referenced with UUIDs.

---

## 3. **Polling or Subscribing for Chat Updates**

- Poll the `chat_requests` table for requests related to the current UUID player:
const { data, error } = await supabase
.from('chat_requests')
.select('*')
.eq('player_id', playerId)
.order('created_at', { ascending: false });
// Display active and recent chats by status

text

- Alternatively, use Supabase Realtime or websocket subscribe to updates:
supabase
.channel('chat_requests')
.on('postgres_changes', { event: '*', schema: 'public', table: 'chat_requests', filter: player_id=eq.${playerId} }, payload => {
// Refresh chat list/messages here
})
.subscribe();

text

---

## 4. **Sending and Receiving Messages**

- Use a join between `chat_requests` (sessions) and `chat_messages` (history):
// On selecting an active chat/request:
const { data, error } = await supabase
.from('chat_messages')
.select('*')
.eq('session_id', selectedRequest.id) // session_id = chat request id
.order('sent_at');

text

- To send a message:
const { error } = await supabase
.from('chat_messages')
.insert([{
session_id: selectedRequest.id,
sender_type: 'player',
sender_id: playerId,
message_text: yourMessage,
sent_at: new Date().toISOString()
}]);

text

- Auto-refresh messages after each send/receive event.
- Optionally, use websocket/subscription to auto-refresh when staff responds.

---

## 5. **Active and Recent Chats UI**

- Display all chats the player owns, split by status:
- `status: 'active'`: Chat in progress (open the chat window!)
- `status: 'waiting'`: Pending (awaiting staff/GRE pickup)
- `status: 'recent'`/`'closed'`: Completed (show chat transcript, but disable send)

---

## 6. **Error Handling and Edge Cases**

- If any create or send fails, display a friendly error in the UI.
- Grey out send/chat actions if session is in `'recent'` or `'closed'` state.
- Always validate that session, playerId, and all required values exist before making API calls.

---

## üèÅ **End-To-End Test**

1. **Login as a new player account.**
2. **Start a chat; verify it appears for your player and immediately for staff.**
3. **Send/receive messages; all use UUID for references.**
4. **GRE closes chat.**
5. **Chat moves to Recent, player can view transcript but not reply.**
6. **Log out/log in from a different account to confirm true RLS.**

---

## üü¢ **What to Refactor/Remove**

- Any code referencing or inserting INT `player_id` references.
- Any logic assuming player_id in chat tables is INT‚Äîalways use the UUID.
- Any non-UUID API calls for player/session/message creation or queries.

---

**If you want a plug-and-play React hook, message listener code, or a template for chat request submission UI, let me know!**  
Paste this where your devs will see it, and double-check all use of `player_id` matches UUID in Supabase Auth and chat tables.