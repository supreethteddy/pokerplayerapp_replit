1) backend-automation.ts

Pass the password to the mail endpoint and use your single public URL.

- const emailResponse = await fetch(`${process.env.PUBLIC_API_URL}/api/email-verification/send-verification`, {
+ const emailResponse = await fetch(`${process.env.PUBLIC_API_URL}/api/email-verification/send-verification`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      email: trimmedEmail,
      playerId: newPlayer.id,
      firstName: trimmedFirstName || 'User',
+     password: req.body.password || ''
    })
});


Also change the resend path similarly (same URL, include password).

2) routes/email-verification.ts

Keep one copy of this file. Replace /send-verification to use Confirm signup (and resend if already registered). We will not use inviteUserByEmail or generateLink anymore.

import express from 'express';
import { supabase } from '../supabase';
const router = express.Router();

// --- SEND CONFIRM-SIGNUP EMAIL ---
router.post('/send-verification', async (req, res) => {
  try {
    const { email, playerId, firstName, password } = req.body;
    if (!email || !playerId) return res.status(400).json({ error: 'Email and playerId required' });

    const { createClient } = await import('@supabase/supabase-js');
    const supabaseAnon = createClient(
      process.env.VITE_SUPABASE_URL!,              // already provided
      process.env.VITE_SUPABASE_ANON_KEY!         // already provided
    );

    // Supabase will confirm the auth user and then send user to this bridge,
    // where WE set players.email_verified=TRUE and finally redirect to login.
    const redirectAfterConfirm =
      `${process.env.PUBLIC_API_URL}/api/email-verification/confirm-bridge?email=${encodeURIComponent(email)}`;

    // 1) Try signup -> sends "Confirm signup" email using your Supabase SMTP/template
    const { error: signErr } = await supabaseAnon.auth.signUp({
      email,
      password: password || 'Temp#' + Math.random().toString(36).slice(2),
      options: { emailRedirectTo: redirectAfterConfirm }
    });

    // 2) If already registered and not confirmed -> resend confirm-signup
    if (signErr && /registered|exists/i.test(signErr.message || '')) {
      const { error: reErr } = await supabaseAnon.auth.resend({
        type: 'signup',
        email,
        options: { emailRedirectTo: redirectAfterConfirm }
      });
      if (reErr) {
        console.error('❌ [RESEND SIGNUP]', reErr);
        return res.status(500).json({ error: 'Failed to resend confirmation email' });
      }
    } else if (signErr) {
      console.error('❌ [SIGNUP EMAIL]', signErr);
      return res.status(500).json({ error: 'Failed to send confirmation email' });
    }

    return res.json({ success: true, message: 'Confirmation email sent' });
  } catch (e) {
    console.error('❌ [SEND CONFIRM SIGNUP]', e);
    return res.status(500).json({ error: 'Failed to send confirmation email' });
  }
});

// --- BRIDGE: set email_verified then redirect to login ---
router.get('/confirm-bridge', async (req, res) => {
  try {
    const email = String(req.query.email || '');
    if (!email) return res.status(400).json({ error: 'Email required' });

    // 1) UPDATE FIRST
    const { error: updateError } = await supabase
      .from('players')
      .update({ email_verified: true, updated_at: new Date().toISOString() })
      .eq('email', email);

    if (updateError) {
      console.error('❌ [CONFIRM BRIDGE] Player update error:', updateError);
      return res.status(500).json({ error: 'Failed to verify email' });
    }

    // 2) REDIRECT TO LOGIN (same origin)
    return res.redirect(`${process.env.PUBLIC_APP_URL}/?verified=true`);
  } catch (e) {
    console.error('❌ [CONFIRM BRIDGE]', e);
    return res.status(500).json({ error: 'Bridge error' });
  }
});

export default router;


You can keep the older token-based endpoints if you want, but they’re no longer needed for this “Confirm signup” flow.