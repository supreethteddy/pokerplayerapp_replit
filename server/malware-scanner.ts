import clamscan from 'clamscan';
import fs from 'fs/promises';
import path from 'path';

let clamAV: any = null;

// Initialize ClamAV scanner
const initializeClamAV = async () => {
  try {
    console.log('üõ°Ô∏è [CLAMAV] Initializing malware scanner...');
    
    // ClamAV configuration
    const clamScanOptions = {
      removeInfected: false, // Don't automatically remove infected files
      quarantineInfected: false, // Don't quarantine
      scanLog: null,
      debugMode: false,
      fileList: null,
      scanRecursively: true,
      clamdscan: {
        active: false, // Use clamdscal if daemon is running
        host: 'localhost',
        port: 3310,
      },
      preference: 'clamdscan' // Prefer daemon if available, fallback to clamscan
    };

    clamAV = await new clamscan().init(clamScanOptions);
    console.log('‚úÖ [CLAMAV] Malware scanner initialized successfully');
    
    // Test the scanner
    const version = await clamAV.getVersion();
    console.log(`üõ°Ô∏è [CLAMAV] Scanner version: ${version}`);
    
    return clamAV;
  } catch (error) {
    console.error('‚ùå [CLAMAV] Failed to initialize:', error);
    console.log('‚ö†Ô∏è [CLAMAV] Malware scanning will be disabled');
    return null;
  }
};

// Scan a file for malware
export const scanFileForMalware = async (filePath: string, fileName: string): Promise<{
  isInfected: boolean;
  viruses?: string[];
  scanResult?: string;
  error?: string;
}> => {
  try {
    // Initialize ClamAV if not already done
    if (!clamAV) {
      clamAV = await initializeClamAV();
      if (!clamAV) {
        return {
          isInfected: false,
          error: 'ClamAV not available - file uploaded without malware scan'
        };
      }
    }

    console.log(`üîç [CLAMAV] Scanning file for malware: ${fileName}`);
    
    // Check if file exists
    try {
      await fs.access(filePath);
    } catch (error) {
      return {
        isInfected: false,
        error: 'File not found for scanning'
      };
    }

    // Perform the malware scan
    const scanResult = await clamAV.scanFile(filePath);
    
    console.log(`üõ°Ô∏è [CLAMAV] Scan completed for ${fileName}:`, {
      isInfected: scanResult.isInfected,
      viruses: scanResult.viruses,
      file: scanResult.file
    });

    if (scanResult.isInfected) {
      console.log(`üö® [CLAMAV] MALWARE DETECTED in ${fileName}:`, scanResult.viruses);
      
      // Attempt to remove infected file
      try {
        await fs.unlink(filePath);
        console.log(`üóëÔ∏è [CLAMAV] Infected file deleted: ${fileName}`);
      } catch (deleteError) {
        console.error(`‚ùå [CLAMAV] Failed to delete infected file: ${fileName}`, deleteError);
      }

      return {
        isInfected: true,
        viruses: scanResult.viruses || [],
        scanResult: 'INFECTED'
      };
    }

    return {
      isInfected: false,
      scanResult: 'CLEAN'
    };

  } catch (error) {
    console.error(`‚ùå [CLAMAV] Error scanning file ${fileName}:`, error);
    return {
      isInfected: false,
      error: `Malware scan failed: ${error instanceof Error ? error.message : 'Unknown error'}`
    };
  }
};

// Scan file buffer for malware (for in-memory scanning)
export const scanBufferForMalware = async (buffer: Buffer, fileName: string): Promise<{
  isInfected: boolean;
  viruses?: string[];
  scanResult?: string;
  error?: string;
}> => {
  try {
    // Initialize ClamAV if not already done
    if (!clamAV) {
      clamAV = await initializeClamAV();
      if (!clamAV) {
        return {
          isInfected: false,
          error: 'ClamAV not available - file uploaded without malware scan'
        };
      }
    }

    console.log(`üîç [CLAMAV] Scanning buffer for malware: ${fileName} (${buffer.length} bytes)`);
    
    // Write buffer to temporary file for scanning
    const tempFilePath = path.join('/tmp', `scan_${Date.now()}_${Math.random().toString(36).substring(7)}`);
    
    try {
      await fs.writeFile(tempFilePath, buffer);
      
      // Scan the temporary file
      const result = await scanFileForMalware(tempFilePath, fileName);
      
      // Clean up temporary file
      try {
        await fs.unlink(tempFilePath);
      } catch (cleanupError) {
        console.warn(`‚ö†Ô∏è [CLAMAV] Failed to cleanup temp file: ${tempFilePath}`);
      }
      
      return result;
    } catch (error) {
      // Ensure temp file cleanup even on error
      try {
        await fs.unlink(tempFilePath);
      } catch (cleanupError) {
        // Ignore cleanup errors
      }
      throw error;
    }

  } catch (error) {
    console.error(`‚ùå [CLAMAV] Error scanning buffer for ${fileName}:`, error);
    return {
      isInfected: false,
      error: `Buffer malware scan failed: ${error instanceof Error ? error.message : 'Unknown error'}`
    };
  }
};

// Initialize ClamAV on module load
initializeClamAV().catch(error => {
  console.warn('‚ö†Ô∏è [CLAMAV] Could not initialize on startup:', error.message);
});

export { clamAV };